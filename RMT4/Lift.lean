import Mathlib.Analysis.Convex.Normed
import Mathlib.Analysis.Convex.Segment
import Mathlib.Topology.Covering
import Mathlib.Topology.LocallyConstant.Basic

set_option autoImplicit false
set_option pp.proofs.withType false

open Set Topology Metric unitInterval

section misc

instance : Top I := ‚ü®1‚ü©
instance : OrderTop I := by refine ‚ü®Œª _ => le_one'‚ü©

lemma isClopen_iff_nhds {Œ± : Type*} [TopologicalSpace Œ±] {s : Set Œ±} :
    IsClopen s ‚Üî ‚àÄ a, ‚àÄ·∂† b in ùìù a, b ‚àà s ‚Üî a ‚àà s where
  mp h a := by
    by_cases h3 : a ‚àà s
    ¬∑ simpa [h3] using h.1.mem_nhds h3
    ¬∑ simpa only [h3, iff_false] using h.2.isOpen_compl.mem_nhds h3
  mpr h := by
    constructor
    ¬∑ simpa [isOpen_iff_mem_nhds] using Œª a ha => by simpa [ha] using h a
    ¬∑ exact ‚ü®by simpa [isOpen_iff_mem_nhds] using Œª a ha => by simpa only [ha, iff_false] using h a‚ü©

end misc

section helpers

variable {E X : Type*} [TopologicalSpace E] [TopologicalSpace X] {f : E ‚Üí X} {Œ≥ : C(I, X)} {A : E}
  {s t t‚ÇÅ t‚ÇÇ : I}

def good (f : E ‚Üí X) (Œ≥ : C(I, X)) (A : E) (t : I) : Prop :=
  ‚àÉ Œì : I ‚Üí E, ContinuousOn Œì (Iic t) ‚àß Œì 0 = A ‚àß ‚àÄ s ‚â§ t, f (Œì s) = Œ≥ s

lemma good_zero (hŒ≥ : Œ≥ 0 = f A) : good f Œ≥ A 0 := by
  refine ‚ü®Œª _ => A, continuousOn_const, rfl, ?_‚ü©
  rintro ‚ü®s, h1, _‚ü© (h3 : s ‚â§ 0)
  simp [le_antisymm h3 h1, hŒ≥]

lemma good_mono (h2 : good f Œ≥ A t‚ÇÇ) (h12 : t‚ÇÅ ‚â§ t‚ÇÇ) : good f Œ≥ A t‚ÇÅ := by
  obtain ‚ü®Œì, h1, h2, h3‚ü© := h2
  exact ‚ü®Œì, ContinuousOn.mono h1 <| Iic_subset_Iic.mpr h12, h2, Œª s' hs' => h3 s' (hs'.trans h12)‚ü©

lemma good_extend {T : Trivialization (f ‚Åª¬π' {Œ≥ t}) f} (h : MapsTo Œ≥ (uIcc t‚ÇÅ t‚ÇÇ) T.baseSet) :
    good f Œ≥ A t‚ÇÅ ‚Üí good f Œ≥ A t‚ÇÇ := by
  rintro ‚ü®Œì, h1, h2, h3‚ü©
  have l2 : T.baseSet ‚àà ùìù (Œ≥ t‚ÇÅ) := T.open_baseSet.mem_nhds <| h ‚ü®inf_le_left, le_sup_left‚ü©
  have l3 : Œ≥ ‚Åª¬π' T.baseSet ‚àà ùìù t‚ÇÅ := Œ≥.continuous_toFun.continuousAt.preimage_mem_nhds l2
  let Œ¥ (s : I) : E := T.invFun (Œ≥ s, (T (Œì t‚ÇÅ)).2)
  let Œî (s : I) : E := if s ‚â§ t‚ÇÅ then Œì s else Œ¥ s
  refine ‚ü®Œî, ?_, by simp [show 0 ‚â§ t‚ÇÅ from t‚ÇÅ.2.1, h2], ?_‚ü©
  ¬∑ apply ContinuousOn.if
    ¬∑ have k1 : Œì t‚ÇÅ ‚àà T.source := by simpa [T.source_eq, h3 t‚ÇÅ le_rfl] using mem_of_mem_nhds l3
      have k2 : (T (Œì t‚ÇÅ)).1 = f (Œì t‚ÇÅ) := T.proj_toFun _ k1
      have k3 : T.invFun (T (Œì t‚ÇÅ)) = Œì t‚ÇÅ := T.left_inv' k1
      intro a ha
      have k4 : a = t‚ÇÅ := by simpa using (frontier_le_subset_eq continuous_id continuous_const) ha.2
      simp_rw [k4, ‚Üê h3 t‚ÇÅ le_rfl, ‚Üê k2, Prod.eta, k3]
    ¬∑ refine h1.mono <| (inter_subset_right _ _).trans (?_ : closure (Iic t‚ÇÅ) ‚äÜ Iic t‚ÇÅ)
      simpa only [closure_Iic] using subset_rfl
    ¬∑ have : ContinuousOn Œ¥ (Œ≥ ‚Åª¬π' T.baseSet) := by
        apply T.continuous_invFun.comp
        ¬∑ apply Continuous.continuousOn
          simpa only [continuous_prod_mk, continuous_const, and_true] using Œ≥.continuous_toFun
        ¬∑ intro u hu ; simpa [T.target_eq] using hu
      apply this.mono
      rintro v ‚ü®hv1, hv2‚ü©
      simp only [not_le] at hv2
      have : closure (Ioi t‚ÇÅ) ‚äÜ Ici t‚ÇÅ := closure_lt_subset_le continuous_const continuous_id
      refine h ‚ü®inf_le_left.trans <| this hv2, (show v ‚â§ t‚ÇÇ from hv1).trans le_sup_right‚ü©
  ¬∑ intro v hv
    by_cases l6 : v ‚â§ t‚ÇÅ
    ¬∑ simp only [LocalEquiv.invFun_as_coe, LocalHomeomorph.coe_coe_symm, l6, ite_true, h3]
    ¬∑ simp only [l6, ite_false]
      have : Œ≥ v ‚àà T.baseSet := h ‚ü®inf_le_left.trans <| not_le.1 l6 |>.le, hv.trans le_sup_right‚ü©
      have l7 : T.invFun (Œ≥ v, (T (Œì t‚ÇÅ)).snd) ‚àà T.source :=
        T.map_target' <| by simp only [T.target_eq, mem_prod, this, mem_univ, and_self]
      rw [‚Üê T.proj_toFun _ l7]
      have : T (T.invFun (Œ≥ v, (T (Œì t‚ÇÅ)).snd)) = (Œ≥ v, (T (Œì t‚ÇÅ)).snd) :=
        T.right_inv' <| by simp only [T.target_eq, mem_prod, this, mem_univ, and_self]
      simp only [LocalEquiv.invFun_as_coe, LocalHomeomorph.coe_coe_symm] at this
      simp [this]

lemma good_nhds_iff (hf : IsCoveringMap f) : ‚àÄ·∂† t' in ùìù t, good f Œ≥ A t' ‚Üî good f Œ≥ A t := by
  obtain ‚ü®_, T, h4‚ü© := hf (Œ≥ t)
  have l1 : T.baseSet ‚àà ùìù (Œ≥ t) := T.open_baseSet.mem_nhds h4
  have l2 : Œ≥ ‚Åª¬π' T.baseSet ‚àà ùìù t := Œ≥.continuous_toFun.continuousAt.preimage_mem_nhds  l1
  simp only [Filter.Eventually, Metric.mem_nhds_iff] at l2 ‚ä¢
  obtain ‚ü®Œµ, hŒµ, l3‚ü© := l2
  refine ‚ü®Œµ, hŒµ, ?_‚ü©
  intro u hu
  have l4 : uIcc t u ‚äÜ ball t Œµ := by
    suffices uIcc t.1 u.1 ‚äÜ ball t.1 Œµ by intro v ; apply this
    simpa only [segment_eq_uIcc] using (convex_ball t.1 Œµ).segment_subset (mem_ball_self hŒµ) hu
  have l5 : MapsTo Œ≥ (uIcc t u) T.baseSet := Œª v hv => l3 (l4 hv)
  have l6 := uIcc_comm t u ‚ñ∏ l5
  exact ‚ü®good_extend l6, good_extend l5‚ü©

end helpers

variable {E X : Type*} [TopologicalSpace E] [TopologicalSpace X] {f : E ‚Üí X} {Œ≥ : C(I, X)} {A : E}

theorem lift (hf : IsCoveringMap f) (hŒ≥ : Œ≥ 0 = f A) : ‚àÉ Œì : C(I, E), Œì 0 = A ‚àß f ‚àò Œì = Œ≥ := by
  suffices {t | good f Œ≥ A t} = univ by
    obtain ‚ü®Œì, h1, h2, h3‚ü© := this.symm ‚ñ∏ mem_univ ‚ä§
    refine ‚ü®‚ü®Œì, ?_‚ü©, h2, funext <| Œª s => h3 s s.2.2‚ü©
    simpa [continuous_iff_continuousOn_univ] using h1
  have l1 : Set.Nonempty {t | good f Œ≥ A t} := ‚ü®0, good_zero hŒ≥‚ü©
  have l2 : IsClopen {t | good f Œ≥ A t} := isClopen_iff_nhds.2 <| Œª t => good_nhds_iff hf
  exact (isClopen_iff.1 l2).resolve_left <| Nonempty.ne_empty l1
